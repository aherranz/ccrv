package es.upm.babel.ccrv;

/*
 * This the class of Serialized Semaphores (SSemaphores). By performing all
 * the operations on SSemaphores (await, signal) inside a monitor (for which
 * the class of monitor-embedded semaphores --MSemaphores-- is used), we can
 * guarantee the two assumptions made regarding pre- and post- counters:
 * - A signal increments both its pre- and post-counters at the same time
 * - The post-counter of a signal is incremented atomically (i.e. with no
 *   interleaved increment of any other counter) of the post-await counter
 *   of the aaken thread (if any).
 * In addition, this class wraps MSemaphore, so the original interface of
 * semaphores is recovered (i.e. semaphore.await() instead of the static
 * invocation used in MSemaphores: MSemaphore.await("<msemaphore name>")).
 * The only exception to the usual interface for semaphores is that SSemaphores
 * allow the programmer to give an optional name to SSemaphores, so the
 * internal counter of those named semaphores can be referenced from inside
 * the invariants.
 */

public class SSemaphore {
    private static MSemaphore msemaphore;
    // The underlying monitor-embedded semaphores
    private String name;
    // The name of the semaphore (either machine-generated or programmer-given)

    public static final int PRE=MSemaphore.PRE;
    public static final int POST=MSemaphore.POST;

    // Constructor/1: This is the 'usual' constructor, which only receives
    // the initial value for the semaphore, thus enabling the programmer to
    // use SSemaphores as traditional semaphores. The only prolem is that,
    // since the new semaphore receives an awkward, automatic, unknown name,
    // the programmer will not be able to refer to it from within the
    // invariants
    public SSemaphore(int nInitialValue) {
	if (msemaphore==null) {msemaphore=new MSemaphore();}

	// this.name=this.toString();
        this.name=""+(msemaphore.getNumberOfSemaphores()+1);
	// The first SSemaphore created without an explicit name will be called
        // "1", the next unnamed semaphore will be called "2" and so on.
	// Generate a unique name for every SSemaphore
	// This line can be changed if another method of generating a unique
	// name for every SSemaphore is preferred.

	this.msemaphore.addMSemaphore(this.name,nInitialValue,true);
	// true: The name of this semaphore was generated by the machine
	// Register the name in the list of known monitor-embedded semaphores
    } // constructor/1

    // Constructor/2: The same as constructor/1 but adding a semaphore name
    // provided by the programmer. By letting the programmer give a name for
    // the semaphore, we will be later able to refer to its internal counter
    // using that name.
    public SSemaphore(int nInitialValue,String sName) {
       if (msemaphore==null) {msemaphore=new MSemaphore();}

       this.name=sName;
       // The name of this semaphore is the one provided by the programmer

       this.msemaphore.addMSemaphore(this.name,nInitialValue,false);
       // false: This semaphore has been named by the programmer
       // Register the semaphore
    } // constructor/2

    public void await() {
	MSemaphore.await(this.name,"");
    } // await

    public void signal() {
	MSemaphore.signal(this.name,"");
    } // signal

    // Await and signal also support one parameter to give a name
    // to the counter preceding and the counter following that specific
    // instruction

    public void await(String sCounterName) {
	MSemaphore.await(this.name,sCounterName);
    } // await

    public void signal(String sCounterName) {
	MSemaphore.signal(this.name,sCounterName);
    } // signal

    // The methods below are simple 'exports' of the methods by the same
    // name in the underlying class MSemaphohore.

    // The same invariant will affect all the operations on SSemaphores
    public static void setInvariant(Invariant oInv) {
	MSemaphore.setInvariant(oInv);
    } // setInvariant

    public static int getCounterSafe(String sCounterName,int nPrePost) {
	return MSemaphore.getCounterSafe(sCounterName,nPrePost);
    } // getCounterSafe

    public static String displayCounters() {
	String sOutput=MSemaphore.displayCounters();

	return sOutput;
    } // displayCounters

    // Returns the current counter of a semaphore named by the programmer
    public static int getValue(String sName) {
	return MSemaphore.getValue(sName);
    } // getValue

    // Increments the counter whose name is given (POST side). If the counter
    // does not exist, it is created with value 1.
    // This method is used to track the execution of instructions that are not
    // await or signal.
    public static void checkpoint(String sName) {
	MSemaphore.checkpoint(sName);
    } // checkpoint

} // class
