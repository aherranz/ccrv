package es.upm.babel.ccrv;

/*
 * This the class of Serialized Semaphores (SSemaphores). By performing all
 * the operations on SSemaphores (await, signal) inside a monitor (for which
 * the class of monitor-embedded semaphores --MSemaphores-- is used), we can
 * guarantee the two assumptions made regarding pre- and post- counters:
 * - A signal increments both its pre- and post-counters at the same time
 * - The post-counter of a signal is incremented atomically (i.e. with no
 *   interleaved increment of any other counter) of the post-await counter
 *   of the awaken thread (if any).
 * In addition, this class wraps MSemaphore, so the original interface of
 * semaphores is recovered (i.e. semaphore.await() instead of the static
 * invocation used in MSemaphores: MSemaphore.await("<msemaphore name>")).
 * The only exception to the usual interface for semaphores is that SSemaphores
 * allow the programmer to give an optional name to SSemaphores, so the
 * internal counter of those named semaphores can be referenced from inside
 * the invariants.
 */

import java.util.function.Function;

public class Semaphore {
  private static MSemaphore msemaphore;
  // The underlying monitor-embedded semaphores
  private String name;
  // The name of the semaphore (either machine-generated or programmer-given)

  public static final int PRE=MSemaphore.PRE;
  public static final int POST=MSemaphore.POST;

  // Constructor/1: This is the 'usual' constructor, which only receives
  // the initial value for the semaphore, thus enabling the programmer to
  // use SSemaphores as traditional semaphores. The only prolem is that,
  // since the new semaphore receives an awkward, automatic, unknown name,
  // the programmer will not be able to refer to it from within the
  // invariants
  public Semaphore(int nInitialValue) {
    if (msemaphore==null) {msemaphore=new MSemaphore();}

    // this.name=this.toString();
    this.name=""+(msemaphore.getNumberOfSemaphores()+1);
    // The first Semaphore created without an explicit name will be called
    // "1", the next unnamed semaphore will be called "2" and so on.
    // Generate a unique name for every Semaphore
    // This line can be changed if another method of generating a unique
    // name for every Semaphore is preferred.

    this.msemaphore.addMSemaphore(this.name,nInitialValue,true);
    // true: The name of this semaphore was generated by the machine
    // Register the name in the list of known monitor-embedded semaphores
  } // constructor/1

    // Constructor/2: The same as constructor/1 but adding a semaphore name
    // provided by the programmer. By letting the programmer give a name for
    // the semaphore, we will be later able to refer to its internal counter
    // using that name.
  public Semaphore(int nInitialValue, String sName) {
    if (msemaphore==null) {msemaphore=new MSemaphore();}

    this.name=sName;
    // The name of this semaphore is the one provided by the programmer

    this.msemaphore.addMSemaphore(this.name,nInitialValue,false);
    // false: This semaphore has been named by the programmer
    // Register the semaphore
  } // constructor/2

  public void await() {
    MSemaphore.await(this.name,"");
  } // await

  public void signal() {
    MSemaphore.signal(this.name,"");
  } // signal

    // Await and signal also support one parameter to give a name
    // to the counter preceding and the counter following that specific
    // instruction

  public void await(String sCounterName) {
    MSemaphore.await(this.name,sCounterName);
  } // await

  public void signal(String sCounterName) {
    MSemaphore.signal(this.name,sCounterName);
  } // signal

    // The methods below are simple 'exports' of the methods by the same
    // name in the underlying class MSemaphohore.

    // The same invariant will affect all the operations on SSemaphores
  public static void setInvariant(Invariant oInv) {
    MSemaphore.setInvariant(oInv);
  } // setInvariant

    // Add an invariant that will be checked before and after every semaphore
    // operation
  public static void addInvariant(Function<Void,Boolean> fInv) {
    MSemaphore.addInvariant(fInv);
  } // addInvariant


    // public static int getCounterSafe(String sCounterName,int nPrePost) {
    // 	 return MSemaphore.getCounterSafe(sCounterName,nPrePost);
    // } // getCounterSafe

    // Return the value of the PREcounter with the given name
  public static int before(String sCounterName) {
    return MSemaphore.before(sCounterName);
  } // before

    // Return the value of the POSTcounter with the given name
  public static int after(String sCounterName) {
    return MSemaphore.after(sCounterName);
  } // after

  public static String displayCounters() {
    String sOutput=MSemaphore.displayCounters();

    return sOutput;
  } // displayCounters

    // Returns the current counter of a semaphore named by the programmer
    // public static int getValue(String sName) {
    // 	return MSemaphore.getValue(sName);
    // } // getValue

    // Returns the current counter of a semaphore named by the programmer
    // public static int getValue(String sName) {
    // 	return MSemaphore.getValue(sName);
    // } // getValue

    // Returns the current counter of a semaphore named by the programmer
  public static int semaphore(String sName) {
    return MSemaphore.semaphore(sName);
  } // getValue


    // Increments the counter whose name is given (POST side). If the counter
    // does not exist, it is created with value 1.
    // This method is used to track the execution of instructions that are not
    // await or signal.
  public static void checkpoint(String sName) {
    MSemaphore.checkpoint(sName);
  } // checkpoint

} // class
